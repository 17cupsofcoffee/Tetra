#[cfg(feature = "legion")]
use legion::*;
use rand::{self, Rng};
use rand::rngs::ThreadRng;

use tetra::{Context, ContextBuilder, Event, State, TetraError};
use tetra::graphics::{self, Color, Texture};
use tetra::graphics::text::{Font, Text};
use tetra::math::Vec2;
use tetra::time;
use tetra::window;

mod components {
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Position {
        pub x: f32,
        pub y: f32,
    }

    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Velocity {
        pub dx: f32,
        pub dy: f32,
    }
}

mod systems {
    use std::time::Duration;

    use legion::*;

    use crate::components::{Position, Velocity};

    const BOUNDS: (f32, f32) = (1280.0 - 26.0, 720.0 - 37.0);
    const GRAVITY: f32 = 0.5;

    #[system(for_each)]
    pub fn update_positions(pos: &mut Position,
                            vel: &mut Velocity,
                            #[resource] delta_time: &Duration) {
        pos.x += vel.dx * delta_time.as_millis() as f32;
        pos.y += vel.dy * delta_time.as_millis() as f32;
        vel.dy += GRAVITY;
        if pos.x > BOUNDS.0 {
            vel.dx *= 1.0;
            pos.x = BOUNDS.0
        } else if pos.x < 0.0 {
            vel.dx *= -1.0;
            pos.x = 0.0;
        }
        if pos.y > BOUNDS.1 {
            vel.dy *= -3.0;
            pos.y = BOUNDS.1;
        } else if pos.y < 0.0 {
            vel.dy = 0.0;
            pos.y = 0.0;
        }
    }
}

struct GameState {
    world: World,
    schedule: Schedule,
    resources: Resources,
    texture: Texture,
    rng: ThreadRng,
    vector_text: Text,
    bunny_count: i32,
}

impl GameState {
    fn new(ctx: &mut Context) -> tetra::Result<Self> {
        let vector_text = Text::new(
            "Press any key to spawn a few bunnies",
            Font::vector(ctx, "./examples/resources/DejaVuSansMono.ttf", 16.0)?,
        );
        Ok(GameState {
            texture: Texture::new(ctx, "./examples/resources/wabbit_alpha.png")?,
            rng: rand::thread_rng(),
            world: World::default(),
            resources: Resources::default(),
            schedule: Schedule::builder()
                // Generated by Legion's macro
                .add_system(systems::update_positions_system())
                .build(),
            vector_text,
            bunny_count: 0
        })
    }

    fn spawn_bunny(&mut self) {
        use crate::components::{Position, Velocity};
        let x = self.rng.gen::<f32>() * 32.0;
        let y = self.rng.gen::<f32>() * 32.0;
        let dx = self.rng.gen::<f32>() * 5.0;
        let dy = self.rng.gen::<f32>() * 5.0;
        self.world.push((Position { x, y }, Velocity { dx, dy }));
        self.bunny_count += 1;
    }
}

impl State for GameState {
    fn update(&mut self, ctx: &mut Context) -> Result<(), TetraError> {
        self.vector_text.set_content(&format!("Press any key to spawn a few bunnies (count: {})", self.bunny_count));
        self.resources.insert(tetra::time::get_delta_time(ctx));
        self.schedule.execute(&mut self.world, &mut self.resources);
        Ok(())
    }

    fn draw(&mut self, ctx: &mut Context) -> tetra::Result {
        use crate::components::Position;
        window::set_title(ctx, &format!("BunnyMark - {:.0} FPS", time::get_fps(ctx)));
        graphics::clear(ctx, Color::rgb(0.392, 0.584, 0.929));
        let mut bunnies = <&Position>::query();
        for position in bunnies.iter(&self.world) {
            self.texture.draw(ctx, Vec2::new(position.x, position.y));
        }
        self.vector_text.draw(ctx, Vec2::new(16.0, 16.0));
        Ok(())
    }

    fn event(&mut self, _ctx: &mut Context, event: Event) -> Result<(), TetraError> {
        match event {
            Event::KeyPressed { .. } => {
                for _ in 0..100 {
                    self.spawn_bunny();
                }
            }
            _ => {}
        }
        Ok(())
    }
}

fn main() -> tetra::Result {
    ContextBuilder::new("Tetra with ECS", 1280, 720)
        .quit_on_escape(true)
        .build()?
        .run(|ctx| GameState::new(ctx))
}
