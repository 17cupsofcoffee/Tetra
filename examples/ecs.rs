use std::time::Duration;

use legion::*;
use rand::rngs::StdRng;
use rand::{self, Rng, SeedableRng};

use tetra::graphics::text::{Font, Text};
use tetra::graphics::{self, Color, Texture};
use tetra::math::Vec2;
use tetra::time;
use tetra::{Context, ContextBuilder, Event, State};

const GRAVITY: f32 = 30.0;
const MAX_X: f32 = 1280.0 - 26.0;
const MAX_Y: f32 = 720.0 - 37.0;

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Position(pub Vec2<f32>);

#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Velocity(pub Vec2<f32>);

#[system(for_each)]
pub fn update_positions(
    Position(pos): &mut Position,
    Velocity(vel): &mut Velocity,
    #[resource] delta_time: &Duration,
    #[resource] rng: &mut StdRng,
) {
    *pos += *vel;
    vel.y += GRAVITY * delta_time.as_secs_f32();

    if pos.x > MAX_X {
        vel.x *= -1.0;
        pos.x = MAX_X;
    } else if pos.x < 0.0 {
        vel.x *= -1.0;
        pos.x = 0.0;
    }

    if pos.y > MAX_Y {
        vel.y *= -0.8;
        pos.y = MAX_Y;

        if rng.gen::<bool>() {
            vel.y -= 3.0 + (rng.gen::<f32>() * 4.0);
        }
    } else if pos.y < 0.0 {
        vel.y = 0.0;
        pos.y = 0.0;
    }
}

struct GameState {
    world: World,
    schedule: Schedule,
    resources: Resources,

    texture: Texture,
    vector_text: Text,
    bunny_count: i32,
}

impl GameState {
    fn new(ctx: &mut Context) -> tetra::Result<Self> {
        let vector_text = Text::new(
            "Press any key to spawn a few bunnies",
            Font::vector(ctx, "./examples/resources/DejaVuSansMono.ttf", 16.0)?,
        );

        let mut resources = Resources::default();
        resources.insert(StdRng::from_entropy());

        Ok(GameState {
            world: World::default(),
            resources,
            schedule: Schedule::builder()
                // Generated by Legion's macro
                .add_system(update_positions_system())
                .build(),

            texture: Texture::new(ctx, "./examples/resources/wabbit_alpha.png")?,
            vector_text,
            bunny_count: 0,
        })
    }

    fn spawn_bunny(&mut self) {
        let mut rng = self.resources.get_mut::<StdRng>().unwrap();

        let x_vel = rng.gen::<f32>() * 5.0;
        let y_vel = (rng.gen::<f32>() * 5.0) - 2.5;

        self.world
            .push((Position(Vec2::zero()), Velocity(Vec2::new(x_vel, y_vel))));

        self.bunny_count += 1;
    }
}

impl State for GameState {
    fn update(&mut self, ctx: &mut Context) -> tetra::Result {
        self.resources.insert(time::get_delta_time(ctx));
        self.schedule.execute(&mut self.world, &mut self.resources);

        Ok(())
    }

    fn draw(&mut self, ctx: &mut Context) -> tetra::Result {
        graphics::clear(ctx, Color::rgb(0.392, 0.584, 0.929));

        let mut bunnies = <&Position>::query();

        for position in bunnies.iter(&self.world) {
            self.texture.draw(ctx, position.0);
        }

        self.vector_text.draw(ctx, Vec2::new(16.0, 16.0));

        Ok(())
    }

    fn event(&mut self, _ctx: &mut Context, event: Event) -> tetra::Result {
        if let Event::KeyPressed { .. } = event {
            for _ in 0..100 {
                self.spawn_bunny();
            }

            self.vector_text.set_content(&format!(
                "Press any key to spawn a few bunnies (count: {})",
                self.bunny_count
            ));
        }

        Ok(())
    }
}

fn main() -> tetra::Result {
    ContextBuilder::new("Tetra with ECS", 1280, 720)
        .quit_on_escape(true)
        .build()?
        .run(GameState::new)
}
